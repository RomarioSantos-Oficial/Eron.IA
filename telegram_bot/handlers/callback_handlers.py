"""
Handlers de callbacks (bot√µes inline) do bot Telegram
"""
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def handle_callback_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler principal para callbacks de bot√µes inline"""
    query = update.callback_query
    await query.answer()
    
    callback_data = query.data
    user_id = str(query.from_user.id)
    
    try:
        # Importar handlers espec√≠ficos
        from .personalization_handlers import handle_personalization_callbacks
        from .preferences_handlers import handle_preferences_callbacks
        from .emotions_handlers import handle_emotions_callbacks
        from .adult_handlers import handle_adult_callbacks
        
        logger.info(f"Callback recebido de {user_id}: {callback_data}")
        
        # Roteamento de callbacks
        # Callbacks espec√≠ficos do fluxo de personaliza√ß√£o completa
        if callback_data.startswith("set_user_gender_"):
            await handle_user_gender_selection(update, context)
        
        elif callback_data.startswith("set_bot_gender_"):
            await handle_bot_gender_selection(update, context)
        
        elif callback_data.startswith("select_name_"):
            await handle_name_selection(update, context)
        
        elif callback_data == "custom_bot_name":
            await handle_custom_name_request(update, context)
        
        elif callback_data.startswith("set_personality_"):
            await handle_personality_selection(update, context)
        
        elif callback_data.startswith("set_language_style_"):
            await handle_language_style_selection(update, context)
        
        elif callback_data.startswith("toggle_topic_"):
            await handle_topic_toggle(update, context)
        
        elif callback_data == "finish_personalization":
            await finish_personalization(update, context)
        
        # Callbacks de personaliza√ß√£o geral (handlers antigos)
        elif callback_data.startswith(('start_personalization', 'personalize_', 'save_', 'complete_personalization', 'cancel_personalization')):
            await handle_personalization_callbacks(update, context)
        
        elif callback_data.startswith(('preferences_', 'pref_')):
            await handle_preferences_callbacks(update, context)
        
        elif callback_data.startswith(('emotions_', 'emotion_')):
            await handle_emotions_callbacks(update, context)
        
        elif callback_data.startswith(('adult_', 'verify_adult')):
            await handle_adult_callbacks(update, context)
        
        # Callbacks gerais
        elif callback_data == "help":
            await show_help_menu(update, context)
        
        elif callback_data == "start_chat":
            await start_conversation(update, context)
        
        elif callback_data == "close_menu":
            await close_menu(update, context)
        
        elif callback_data == "confirm_clear_all":
            await confirm_clear_all(update, context)
        
        elif callback_data == "cancel_clear":
            await cancel_clear(update, context)
        
        elif callback_data == "start_full_personalization":
            await start_full_personalization(update, context)
        
        elif callback_data == "skip_personalization":
            await skip_personalization(update, context)

        else:
            await query.edit_message_text("‚ùå Op√ß√£o n√£o reconhecida.")
    
    except Exception as e:
        logger.error(f"Erro ao processar callback {callback_data}: {e}")
        await query.edit_message_text("‚ùå Erro interno. Tente novamente.")

async def show_help_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostrar menu de ajuda via callback"""
    help_text = """
ü§ñ **AJUDA DO BOT**

**Como usar:**
‚Ä¢ Digite qualquer mensagem para conversar
‚Ä¢ Use os bot√µes para navegar pelos menus
‚Ä¢ Personalize o bot para uma experi√™ncia √∫nica

**Comandos:**
‚Ä¢ /start - Iniciar
‚Ä¢ /menu - Menu principal  
‚Ä¢ /help - Esta ajuda
‚Ä¢ /personalizar - Configura√ß√µes
"""
    
    keyboard = [
        [InlineKeyboardButton("üîô Voltar ao Menu", callback_data="menu_principal")],
        [InlineKeyboardButton("‚ùå Fechar", callback_data="close_menu")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.callback_query.edit_message_text(
        help_text,
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def start_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Iniciar conversa√ß√£o via callback"""
    await update.callback_query.edit_message_text(
        "üí¨ **Perfeito!** Agora voc√™ pode conversar comigo normalmente.\n\n"
        "Apenas digite qualquer mensagem e eu responderei! üòä\n\n"
        "Dica: Use /menu a qualquer momento para ver op√ß√µes."
    )

async def close_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fechar menu via callback"""
    await update.callback_query.edit_message_text(
        "‚úÖ Menu fechado.\n\n"
        "Digite qualquer mensagem para conversar ou use /menu para ver op√ß√µes novamente."
    )

async def handle_feedback_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handler para feedback de mensagens"""
    query = update.callback_query
    await query.answer()
    
    callback_data = query.data
    user_id = str(query.from_user.id)
    
    if callback_data.startswith('feedback_'):
        feedback_type = callback_data.split('_')[1]
        message_id = callback_data.split('_')[2] if len(callback_data.split('_')) > 2 else None
        
        try:
            # Registrar feedback
            from learning.feedback_system import FeedbackSystem as FeedbackService
            feedback_service = FeedbackService()
            
            success = feedback_service.register_feedback(
                user_id=user_id,
                message_id=message_id,
                feedback_type=feedback_type,
                platform='telegram'
            )
            
            if success:
                if feedback_type == 'positive':
                    await query.edit_message_text("üëç Obrigado pelo feedback positivo!")
                else:
                    await query.edit_message_text("üëé Obrigado pelo feedback. Vou melhorar!")
            else:
                await query.edit_message_text("‚ùå Erro ao registrar feedback.")
                
        except Exception as e:
            logger.error(f"Erro ao processar feedback: {e}")
            await query.edit_message_text("‚ùå Erro interno ao processar feedback.")

async def confirm_clear_all(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Confirmar e executar reset completo - iniciar fluxo de personaliza√ß√£o"""
    query = update.callback_query
    user_id = str(query.from_user.id)
    
    try:
        # Importar servi√ßos necess√°rios
        import sys
        import os
        sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
        from src.user_profile_db import UserProfileDB as UserService
        from src.memory import EronMemory
        from src.preferences import PreferencesManager
        from src.emotion_system import EmotionSystem
        
        user_service = UserService()
        memory = EronMemory()
        preferences = PreferencesManager()
        emotions = EmotionSystem()
        
        # Resetar dados do usu√°rio no banco
        reset_success = user_service.reset_user_profile(user_id)
        
        # Limpar mem√≥ria de conversas
        try:
            memory.clear_user_memory(user_id)
        except:
            pass  # Continuar mesmo se houver erro na mem√≥ria
        
        # Resetar prefer√™ncias
        try:
            preferences.reset_user_preferences(user_id)
        except:
            pass
        
        # Resetar emo√ß√µes
        try:
            emotions.reset_user_emotions(user_id)
        except:
            pass
        
        # Limpar dados de contexto do Telegram
        context.user_data.clear()
        
        if reset_success:
            # Iniciar fluxo de personaliza√ß√£o completa como primeira vez
            keyboard = [
                [
                    InlineKeyboardButton("‚úÖ Sim, vamos personalizar!", callback_data="start_full_personalization"),
                    InlineKeyboardButton("‚ùå N√£o, obrigado", callback_data="skip_personalization")
                ]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(
                "üéâ **RESET CONCLU√çDO COM SUCESSO!**\n\n"
                "Ol√°! Eu sou o **Eron**, seu assistente de IA personalizado!\n\n"
                "üéØ Para melhorar sua experi√™ncia, gostaria de me personalizar?\n\n"
                "**Com a personaliza√ß√£o voc√™ pode:**\n"
                "‚Ä¢ Escolher seu nome e informa√ß√µes pessoais\n"
                "‚Ä¢ Definir meu nome e personalidade\n"
                "‚Ä¢ Configurar idioma e t√≥picos de interesse\n"
                "‚Ä¢ Ajustar prefer√™ncias de conversa\n\n"
                "**Gostaria de come√ßar a personaliza√ß√£o completa?**",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        else:
            await query.edit_message_text(
                "‚ùå **ERRO NO RESET**\n\n"
                "Houve um problema ao resetar algumas configura√ß√µes.\n"
                "Tente usar /start para reconfigurar manualmente."
            )
    
    except Exception as e:
        logger.error(f"Erro ao resetar perfil: {e}")
        await query.edit_message_text(
            "‚ùå **ERRO T√âCNICO**\n\n"
            "N√£o foi poss√≠vel completar o reset.\n"
            "Tente novamente em alguns instantes."
        )

async def cancel_clear(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancelar opera√ß√£o de reset"""
    await update.callback_query.edit_message_text(
        "‚úÖ **RESET CANCELADO**\n\n"
        "Suas configura√ß√µes est√£o seguras! üòä\n\n"
        "Use /menu para ver outras op√ß√µes ou continue conversando normalmente."
    )

async def start_full_personalization(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Iniciar personaliza√ß√£o completa ap√≥s reset"""
    query = update.callback_query
    user_id = str(query.from_user.id)
    
    await query.answer()
    
    # Marcar que est√° iniciando personaliza√ß√£o
    context.user_data['personalizing'] = True
    context.user_data['personalization_step'] = 'user_name'
    
    await query.edit_message_text(
        "üéØ **VAMOS COME√áAR A PERSONALIZA√á√ÉO!**\n\n"
        "**Passo 1/8: Informa√ß√µes Pessoais**\n\n"
        "üë§ Como voc√™ gostaria de ser chamado?\n"
        "Digite seu nome ou apelido:",
        parse_mode='Markdown'
    )

async def skip_personalization(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Pular personaliza√ß√£o ap√≥s reset"""
    query = update.callback_query
    user_id = str(query.from_user.id)
    
    await query.answer()
    
    # Limpar dados de personaliza√ß√£o
    context.user_data.clear()
    
    keyboard = [
        [InlineKeyboardButton("üìã Menu Principal", callback_data="menu_principal")],
        [InlineKeyboardButton("üé® Personalizar Depois", callback_data="start_personalization")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        "üëç **Tudo bem!**\n\n"
        "Voc√™ pode personalizar o Eron a qualquer momento usando:\n"
        "‚Ä¢ /personalizar - Menu de personaliza√ß√£o\n"
        "‚Ä¢ /menu - Menu principal\n\n"
        "üí¨ **Agora voc√™ j√° pode conversar comigo!**\n"
        "Digite qualquer mensagem para come√ßar.",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def handle_user_gender_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Processar sele√ß√£o de g√™nero do usu√°rio"""
    query = update.callback_query
    user_id = str(query.from_user.id)
    gender = query.data.replace("set_user_gender_", "")
    
    print(f"[DEBUG] Processando sele√ß√£o de g√™nero: {gender} para usu√°rio {user_id}")
    
    try:
        import sys
        import os
        sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
        from src.user_profile_db import UserProfileDB as UserService
        
        user_service = UserService()
        print(f"[DEBUG] Salvando g√™nero {gender} no banco...")
        user_service.update_profile(user_id, user_gender=gender)
        print(f"[DEBUG] G√™nero salvo com sucesso!")
        
        # Pr√≥ximo passo: data de nascimento
        context.user_data['personalization_step'] = 'birth_date'
        
        gender_display = {
            'masculino': 'üë® Masculino',
            'feminino': 'üë© Feminino',
            'outro': 'üåü Outro',
            'prefiro_nao_dizer': 'ü§ê Prefiro n√£o dizer'
        }
        
        print(f"[DEBUG] Editando mensagem para pr√≥ximo passo...")
        
        await query.edit_message_text(
            f"‚úÖ G√™nero salvo: **{gender_display.get(gender, gender)}**\n\n"
            "**Passo 3/8: Data de Nascimento**\n\n"
            "üìÖ Digite sua data de nascimento no formato **DD/MM/AAAA**\n"
            "Exemplo: 25/12/1995\n\n"
            "‚ö†Ô∏è *Sua idade real determinar√° acesso √†s funcionalidades*",
            parse_mode='Markdown'
        )
        
        print(f"[DEBUG] Mensagem editada com sucesso!")
        
    except Exception as e:
        logger.error(f"Erro ao salvar g√™nero do usu√°rio: {e}")
        print(f"[DEBUG] Erro completo: {e}")
        await query.edit_message_text("‚ùå Erro ao salvar g√™nero. Tente novamente.")

async def handle_bot_gender_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Processar sele√ß√£o de g√™nero do bot"""
    query = update.callback_query
    user_id = str(query.from_user.id)
    gender = query.data.replace("set_bot_gender_", "")
    
    try:
        import sys
        import os
        sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
        from src.user_profile_db import UserProfileDB as UserService
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup
        
        user_service = UserService()
        user_service.update_profile(user_id, bot_gender=gender)
        
        # Pr√≥ximo passo: nome do bot com sugest√µes baseadas no g√™nero
        context.user_data['personalization_step'] = 'bot_name'
        context.user_data['bot_gender'] = gender
        
        gender_display = {
            'masculino': 'üë® Masculino',
            'feminino': 'üë© Feminino', 
            'neutro': '‚öñÔ∏è Neutro'
        }
        
        # Sugest√µes de nomes baseadas no g√™nero
        names_suggestions = {
            'masculino': ["ü§ñ Eron", "‚ö° Alex", "üéØ Bruno", "üî• Carlos", "üí´ Diego"],
            'feminino': ["üåü Ana", "ÔøΩ Bella", "üå∏ Clara", "‚ú® Diana", "ü¶ã Eva"],
            'neutro': ["üîÆ Taylor", "üåà Jordan", "‚≠ê Morgan", "üé® Sage", "üåô Phoenix"]
        }
        
        suggestions = names_suggestions.get(gender, names_suggestions['neutro'])
        
        # Criar keyboard com sugest√µes + op√ß√£o personalizada
        keyboard = []
        for name in suggestions:
            callback_name = name.split(" ")[1]  # Remove emoji
            keyboard.append([InlineKeyboardButton(name, callback_data=f"select_name_{callback_name}")])
        
        # Adicionar op√ß√£o para nome personalizado
        keyboard.append([InlineKeyboardButton("‚úèÔ∏è Outro nome (personalizar)", callback_data="custom_bot_name")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            f"‚úÖ G√™nero do bot salvo: **{gender_display.get(gender, gender)}**\n\n"
            "**Passo 5/8: Nome do Bot**\n\n"
            "ü§ñ Escolha um nome sugerido ou personalize:\n\n"
            "üí° *Dica: Os nomes sugeridos foram selecionados com base no g√™nero escolhido*",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erro ao salvar g√™nero do bot: {e}")
        await query.edit_message_text("‚ùå Erro ao salvar g√™nero. Tente novamente.")

async def handle_personality_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Processar sele√ß√£o de personalidade do bot"""
    query = update.callback_query
    user_id = str(query.from_user.id)
    personality = query.data.replace("set_personality_", "")
    
    try:
        import sys
        import os
        sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
        from src.user_profile_db import UserProfileDB as UserService
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup
        
        user_service = UserService()
        user_service.update_profile(user_id, bot_personality=personality)
        
        # Pr√≥ximo passo: estilo de linguagem
        context.user_data['personalization_step'] = 'language_style'
        
        personality_display = {
            'amigavel': 'üòä Amig√°vel',
            'profissional': 'üíº Profissional',
            'divertido': 'üéâ Divertido',
            'formal': 'üé≠ Formal'
        }
        
        keyboard = [
            [InlineKeyboardButton("üí¨ Informal", callback_data="set_language_style_informal")],
            [InlineKeyboardButton("üé© Formal", callback_data="set_language_style_formal")],
            [InlineKeyboardButton("üî¨ T√©cnico", callback_data="set_language_style_tecnico")],
            [InlineKeyboardButton("üìñ Simples", callback_data="set_language_style_simples")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            f"‚úÖ Personalidade salva: **{personality_display.get(personality, personality)}**\n\n"
            "**Passo 7/8: Estilo de Linguagem**\n\n"
            "üó£Ô∏è Como voc√™ prefere que eu me comunique?",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erro ao salvar personalidade: {e}")
        await query.edit_message_text("‚ùå Erro ao salvar personalidade. Tente novamente.")

async def handle_language_style_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Processar sele√ß√£o de estilo de linguagem"""
    query = update.callback_query
    user_id = str(query.from_user.id)
    language_style = query.data.replace("set_language_style_", "")
    
    try:
        import sys
        import os
        sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
        from src.user_profile_db import UserProfileDB as UserService
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup
        
        user_service = UserService()
        user_service.update_profile(user_id, bot_language=language_style)
        
        # Pr√≥ximo passo: t√≥picos de interesse
        context.user_data['personalization_step'] = 'topics'
        context.user_data['selected_topics'] = []
        
        style_display = {
            'informal': 'üí¨ Informal',
            'formal': 'üé© Formal',
            'tecnico': 'üî¨ T√©cnico',
            'simples': 'üìñ Simples'
        }
        
        # T√≥picos dispon√≠veis (mesmos da vers√£o web)
        keyboard = [
            [InlineKeyboardButton("üíª Tecnologia", callback_data="toggle_topic_tecnologia")],
            [InlineKeyboardButton("üî¨ Ci√™ncia", callback_data="toggle_topic_ciencia")],
            [InlineKeyboardButton("üé® Arte", callback_data="toggle_topic_arte")],
            [InlineKeyboardButton("üìö Literatura", callback_data="toggle_topic_literatura")],
            [InlineKeyboardButton("üéµ M√∫sica", callback_data="toggle_topic_musica")],
            [InlineKeyboardButton("‚öΩ Esportes", callback_data="toggle_topic_esportes")],
            [InlineKeyboardButton("‚úàÔ∏è Viagens", callback_data="toggle_topic_viagens")],
            [InlineKeyboardButton("üç≥ Culin√°ria", callback_data="toggle_topic_culinaria")],
            [InlineKeyboardButton("üè• Sa√∫de", callback_data="toggle_topic_saude")],
            [InlineKeyboardButton("ü§î Filosofia", callback_data="toggle_topic_filosofia")],
            [InlineKeyboardButton("‚úÖ Finalizar", callback_data="finish_personalization")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            f"‚úÖ Estilo salvo: **{style_display.get(language_style, language_style)}**\n\n"
            "**Passo 8/8: T√≥picos de Interesse**\n\n"
            "üìã Selecione os t√≥picos que mais te interessam:\n"
            "(Clique nos t√≥picos para selecion√°-los)\n\n"
            "üîπ **Selecionados:** Nenhum ainda\n\n"
            "Quando terminar, clique em ‚úÖ Finalizar",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erro ao salvar estilo de linguagem: {e}")
        await query.edit_message_text("‚ùå Erro ao salvar estilo. Tente novamente.")

async def handle_topic_toggle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Processar sele√ß√£o/desele√ß√£o de t√≥picos de interesse"""
    query = update.callback_query
    user_id = str(query.from_user.id)
    topic = query.data.replace("toggle_topic_", "")
    
    try:
        # Gerenciar lista de t√≥picos selecionados
        selected_topics = context.user_data.get('selected_topics', [])
        
        if topic in selected_topics:
            selected_topics.remove(topic)
        else:
            selected_topics.append(topic)
        
        context.user_data['selected_topics'] = selected_topics
        
        # Mapeamento de t√≥picos com emojis
        topic_display = {
            'tecnologia': 'üíª Tecnologia',
            'ciencia': 'üî¨ Ci√™ncia',
            'arte': 'üé® Arte',
            'literatura': 'üìö Literatura',
            'musica': 'üéµ M√∫sica',
            'esportes': '‚öΩ Esportes',
            'viagens': '‚úàÔ∏è Viagens',
            'culinaria': 'üç≥ Culin√°ria',
            'saude': 'üè• Sa√∫de',
            'filosofia': 'ü§î Filosofia'
        }
        
        # Criar keyboard atualizada com marca√ß√µes
        keyboard = []
        for topic_key, topic_name in topic_display.items():
            if topic_key in selected_topics:
                button_text = f"‚úÖ {topic_name}"
            else:
                button_text = f"‚ö™ {topic_name}"
            keyboard.append([InlineKeyboardButton(button_text, callback_data=f"toggle_topic_{topic_key}")])
        
        keyboard.append([InlineKeyboardButton("‚úÖ Finalizar", callback_data="finish_personalization")])
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Mostrar t√≥picos selecionados
        if selected_topics:
            selected_text = ", ".join([topic_display.get(t, t) for t in selected_topics])
        else:
            selected_text = "Nenhum ainda"
        
        await query.edit_message_text(
            "**Passo 8/8: T√≥picos de Interesse**\n\n"
            "üìã Selecione os t√≥picos que mais te interessam:\n"
            "(Clique nos t√≥picos para selecion√°-los)\n\n"
            f"üîπ **Selecionados:** {selected_text}\n\n"
            "Quando terminar, clique em ‚úÖ Finalizar",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erro ao processar t√≥pico: {e}")
        await query.edit_message_text("‚ùå Erro ao processar t√≥pico. Tente novamente.")

async def finish_personalization(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Finalizar o processo de personaliza√ß√£o completa"""
    query = update.callback_query
    user_id = str(query.from_user.id)
    
    try:
        import sys
        import os
        sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
        from src.user_profile_db import UserProfileDB as UserService
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup
        
        user_service = UserService()
        
        # Salvar t√≥picos selecionados
        selected_topics = context.user_data.get('selected_topics', [])
        if selected_topics:
            topics_str = ",".join(selected_topics)
            user_service.update_profile(user_id, preferred_topics=topics_str)
        
        # Obter dados do usu√°rio para resumo
        user_data = user_service.get_profile(user_id)
        user_age = context.user_data.get('user_age', 0)
        
        # Limpar dados tempor√°rios
        context.user_data.clear()
        
        # Criar resumo da personaliza√ß√£o
        summary = f"""üéâ **PERSONALIZA√á√ÉO CONCLU√çDA!**

üë§ **Suas Informa√ß√µes:**
‚Ä¢ Nome: {user_data.get('user_name', 'N√£o informado')}
‚Ä¢ G√™nero: {user_data.get('user_gender', 'N√£o informado')}
‚Ä¢ Idade: {user_age} anos

ü§ñ **Configura√ß√µes do Bot:**
‚Ä¢ Nome: {user_data.get('bot_name', 'Eron')}
‚Ä¢ G√™nero: {user_data.get('bot_gender', 'Masculino')}
‚Ä¢ Personalidade: {user_data.get('bot_personality', 'Amig√°vel')}
‚Ä¢ Linguagem: {user_data.get('bot_language', 'Informal')}

üìã **T√≥picos de Interesse:**
{', '.join(selected_topics) if selected_topics else 'Nenhum selecionado'}

‚ú® **Agora estou totalmente personalizado para voc√™!**"""
        
        keyboard = [
            [InlineKeyboardButton("üí¨ Come√ßar a Conversar", callback_data="start_chat")],
            [InlineKeyboardButton("üìã Menu Principal", callback_data="menu_principal")]
        ]
        
        # Se for maior de 18, mencionar configura√ß√µes adultas dispon√≠veis no menu
        if user_age >= 18:
            summary += "\n\nüîû **Nota:** Configura√ß√µes adultas dispon√≠veis no menu /personalizar"
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            summary,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erro ao finalizar personaliza√ß√£o: {e}")
        await query.edit_message_text(
            "‚úÖ **Personaliza√ß√£o conclu√≠da!**\n\n"
            "üí¨ Agora voc√™ pode conversar comigo normalmente.\n"
            "Use /menu para acessar outras op√ß√µes."
        )

async def handle_name_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Processar sele√ß√£o de nome sugerido"""
    query = update.callback_query
    user_id = str(query.from_user.id)
    selected_name = query.data.replace("select_name_", "")
    
    try:
        import sys
        import os
        sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
        from src.user_profile_db import UserProfileDB as UserService
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup
        
        user_service = UserService()
        user_service.update_profile(user_id, bot_name=selected_name)
        
        # Pr√≥ximo passo: personalidade do bot
        context.user_data['personalization_step'] = 'bot_personality'
        
        # Verificar se √© maior de idade para mostrar op√ß√µes adultas
        user_age = context.user_data.get('user_age', 0)
        
        keyboard = [
            [InlineKeyboardButton("üòä Amig√°vel", callback_data="set_personality_amigavel")],
            [InlineKeyboardButton("üíº Profissional", callback_data="set_personality_profissional")],
            [InlineKeyboardButton("üéâ Divertido", callback_data="set_personality_divertido")],
            [InlineKeyboardButton("üé≠ Formal", callback_data="set_personality_formal")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            f"‚úÖ Nome salvo: **{selected_name}**\n\n"
            "**Passo 6/8: Personalidade do Bot**\n\n"
            "üé≠ Que personalidade voc√™ prefere para mim?",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Erro ao salvar nome selecionado: {e}")
        await query.edit_message_text("‚ùå Erro ao salvar nome. Tente novamente.")

async def handle_custom_name_request(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Solicitar nome personalizado"""
    query = update.callback_query
    
    # Definir que o usu√°rio vai digitar um nome personalizado
    context.user_data['personalization_step'] = 'bot_name_custom'
    
    await query.edit_message_text(
        "‚úèÔ∏è **Nome Personalizado**\n\n"
        "ü§ñ Digite o nome que voc√™ gostaria de dar ao seu assistente:\n\n"
        "üí° *Pode ser qualquer nome que voc√™ preferir!*"
    )